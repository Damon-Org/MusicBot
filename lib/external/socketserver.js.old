const
    EventEmitter = require('events');
    Net = require('net');

module.exports = class SocketServer extends EventEmitter {
    /**
     * @constructor
     */
    constructor() {
        super();

        this.port = 5432;
        this.ready = false;

        this.clients = new Map();
    }

    /**
     * @param {Net.Socket} socket
     */
    clientConnect(socket) {
        this.emit('clientConnect', socket);

        const
            clientDetails = socket.address(),
            clientId = clientDetails.address + ':' + clientDetails.port;
        this.clients.set(clientId, socket);

        console.log(`Client connected: ${clientId}`);
    }

    /**
     * @param {Boolean} causedByError if the disconnect was caused by a socket error
     * @param {Net.Socket} socket
     */
    clientDisconnect(causedByError, socket) {
        this.emit('clientDisconnect');

        const
            clientDetails = socket.address(),
            clientId = clientDetails.address + ':' + clientDetails.port;

        this.clients.delete(clientId);
    }

    /**
     * @param {String} clientId A unique id to identify sockets
     * @param {Buffer} buffer
     */
    clientMessage(clientId, buffer) {
        let json = null;

        try {
            const string = buffer.toString();
            json = JSON.parse(string);
        } catch (e) {
            const socket = this.clients.get(clientId);
            socket.write('Buffer is not a valid request.');

            return;
        }

        this.emit('message', socket, json);
    }

    onConnection(socket) {
        socket.on('connect', () => this.clientConnect(socket));

        socket.on('data', buffer => this.clientMessage(clientId, buffer));

        socket.on('close', causedByError => this.clientDisconnect(causedByError, socket));
    }

    isPortInUse(port) {
        return new Promise((resolve, reject) => {
            const server = new Net.Server();

            server.listen(port, 'localhost');

            server.on('error', () => {
                resolve(true);
            });

            server.on('listening', () => {
                server.close();
                resolve(false);
            });
        });
    }

    kill() {
        if (this.server) {
            return new Promise((resolve, reject) => {
                const clients = this.clients.values();

                for (let i = 0; i < clients.length; i++) {
                    clients[i].destroy();
                }

                resolve();
            });
        }
    }

    async setup() {
        while (await this.isPortInUse(this.port)) {
            this.port++;
        }

        this.emit('beforeready');

        this.startServer();
    }

    startServer() {
        this.server = new Net.Server();

        this.server.listen(this.port, '0.0.0.0', () => {
            this.emit('ready');
        });

        this.server.on('connection', socket => this.clientConnect(socket));
    }
}
